## **1. Motivation: Why Lambda Expressions?**

Before Java 8, Java programs were **verbosely object-oriented**:
you had to define **anonymous inner classes** even for one-line behaviors.

Example (pre-Java 8):

```java
button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        System.out.println("Clicked!");
    }
});
```

*Too much code for a simple action.*

**What’s actually important here — *the object*, or *the behavior*?**

**Lambda expressions** introduce a more concise, functional way to express behavior as **data**.

---

## **2. What Is a Lambda Expression?**

A **lambda expression** is a short block of code that takes parameters and returns a value —
just like a method, but **without a name**.

### General form:

```java
(parameters) -> expression
```

or

```java
(parameters) -> { statements; }
```

Examples:

```java
(int x, int y) -> x + y
() -> System.out.println("Hello!")
s -> s.toUpperCase()
```

---

### Example 1 – Runnable

```java
Runnable r = () -> System.out.println("Running in a thread!");
new Thread(r).start();
```

Equivalent to:

```java
new Thread(new Runnable() {
    public void run() { System.out.println("Running in a thread!"); }
}).start();
```

---

### Example 2 – Comparator

```java
Comparator<String> byLength = (a, b) -> Integer.compare(a.length(), b.length());
System.out.println(byLength.compare("hi", "hello")); // negative value
```

⚡ Lambdas drastically reduce boilerplate when working with single-method interfaces.

---

## **3. Functional Interfaces**

A **functional interface** is an interface with exactly **one abstract method**.

Examples from the JDK:

* `Runnable` → `void run()`
* `Comparator<T>` → `int compare(T a, T b)`
* `Predicate<T>` → `boolean test(T t)`
* `Function<T,R>` → `R apply(T t)`
* `Consumer<T>` → `void accept(T t)`
* `Supplier<T>` → `T get()`

You can also define your own:

```java
@FunctionalInterface
interface Operation {
    int apply(int a, int b);
}
```

Then use it:

```java
Operation add = (x, y) -> x + y;
Operation multiply = (x, y) -> x * y;
System.out.println(add.apply(2, 3));      // 5
System.out.println(multiply.apply(2, 3)); // 6
```

**lambdas *implement* interfaces, not classes.**

---

## **4. Type Inference and Syntax Variations**

Java can infer parameter types automatically.

```java
(a, b) -> a + b
```

is equivalent to:

```java
(int a, int b) -> a + b
```

If there’s only one parameter, parentheses can be omitted:

```java
s -> s.length()
```

If the body is a single expression, braces `{}` and `return` are optional.

⚠️ **Pitfall:**
If you use multiple statements, braces are mandatory:

```java
(x, y) -> {
    int sum = x + y;
    return sum;
}
```

---

## **5. Lambdas and Scope**

Lambdas can access **effectively final** local variables from the enclosing scope.

```java
int base = 10;
Function<Integer, Integer> addBase = x -> x + base;
System.out.println(addBase.apply(5)); // 15
```

⚠️ You **cannot modify** captured variables:

```java
int count = 0;
// count++; // ❌ cannot change captured variable
```

---

## **6. Built-in Functional Interfaces (java.util.function)**

| Interface           | Method              | Example                                                  |
| ------------------- | ------------------- | -------------------------------------------------------- |
| `Predicate<T>`      | `boolean test(T t)` | `Predicate<Integer> isEven = n -> n % 2 == 0;`           |
| `Function<T,R>`     | `R apply(T t)`      | `Function<String,Integer> length = s -> s.length();`     |
| `Consumer<T>`       | `void accept(T t)`  | `Consumer<String> printer = s -> System.out.println(s);` |
| `Supplier<T>`       | `T get()`           | `Supplier<Double> rand = () -> Math.random();`           |
| `BiFunction<T,U,R>` | `R apply(T t, U u)` | `(a, b) -> a + b`                                        |

---