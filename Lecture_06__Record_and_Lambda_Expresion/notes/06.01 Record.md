## **1. Motivation: Why Records?**

In Java, we often create classes whose only purpose is to **store data** ‚Äî such as simple DTOs (Data Transfer Objects).

Before Java 14 (and officially since Java 16+), we had to write:

```java
public class Point {
    private final int x;
    private final int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public int x() { return x; }
    public int y() { return y; }

    @Override
    public boolean equals(Object o) { ... }
    @Override
    public int hashCode() { ... }
    @Override
    public String toString() { ... }
}
```

**Records** were introduced to solve exactly this ‚Äî
to create immutable data carriers *without* boilerplate.

---

## **2. Defining a Record**

A **record** is a *special kind of class* that:

* is **immutable** (fields are final),
* automatically provides:

    * constructor,
    * `equals()`, `hashCode()`,
    * `toString()`,
    * accessors (like getters).

### Syntax

```java
public record Point(int x, int y) {}
```

That‚Äôs all you need!

Equivalent to a class with:

```java
private final int x;
private final int y;
public int x() { return x; }
public int y() { return y; }
public boolean equals(Object o) { ... }
public int hashCode() { ... }
public String toString() { ... }
```

---

### Example: Simple Use

```java
Point p1 = new Point(2, 3);
Point p2 = new Point(2, 3);

System.out.println(p1);          // Point[x=2, y=3]
System.out.println(p1.equals(p2)); // true
```

Records automatically define `equals()` and `hashCode()` based on all fields.

---

## **3. Accessors and Components**

In records, **fields are called components**, and their accessors are automatically created.

Example:

```java
record Student(String name, int age) {}
```

Now you can write:

```java
Student s = new Student("Alice", 20);
System.out.println(s.name());
System.out.println(s.age());
```

‚ö†Ô∏è *No `getName()` or `getAge()` ‚Äî the methods are exactly the component names.*

---

## **4. Compact Constructors**

Records automatically create a *canonical constructor*, but you can override it if you need validation or transformation.

### Example

```java
record Temperature(double celsius) {
    public Temperature {
        if (celsius < -273.15)
            throw new IllegalArgumentException("Below absolute zero!");
    }
}
```

Here, `public Temperature { ... }` is a **compact constructor**,
which automatically assigns all parameters.

Equivalent to:

```java
public Temperature(double celsius) {
    if (celsius < -273.15)
        throw new IllegalArgumentException("Below absolute zero!");
    this.celsius = celsius;
}
```

**How compact constructors improve readability?**

---

## **5. Custom Methods**

Records can contain **custom methods** just like normal classes.

Example:

```java
record Rectangle(double width, double height) {
    public double area() {
        return width * height;
    }
}
```


## **6. Static Fields and Methods**

Records may also have static members ‚Äî constants, factory methods, etc.

Example:

```java
record Circle(double radius) {
    static final double PI = 3.14159;
    public double area() { return PI * radius * radius; }
    public static Circle unitCircle() { return new Circle(1.0); }
}
```

Usage:

```java
Circle c = Circle.unitCircle();
System.out.println(c.area());
```

---

## **7. Nested Records**

Records can be nested inside other classes or records.

Example:

```java
class Library {
    record Book(String title, String author) {}
}
```

Usage:

```java
Library.Book b = new Library.Book("Java", "James Gosling");
```

---

## **8. Limitations of Records**

Records are **not full replacements for classes**.

| Feature                        | Supported? | Notes                                  |
| ------------------------------ | ---------- | -------------------------------------- |
| Inheritance                    | ‚ùå          | Records are implicitly `final`.        |
| Extending other classes        | ‚ùå          | Records can only implement interfaces. |
| Mutable fields                 | ‚ùå          | All components are final.              |
| Custom fields (non-components) | ‚úÖ          | Allowed, but rare.                     |

Example of a custom field:

```java
record Person(String name) {
    static int count = 0; // static field allowed
}
```

---

## **9. Records and Interfaces**

A record **can implement interfaces**:

```java
interface Shape {
    double area();
}

record Circle(double radius) implements Shape {
    public double area() { return Math.PI * radius * radius; }
}
```

‚úÖ This is common for domain models and DTOs.

---

## **10. Records and Pattern Matching**

Records integrate nicely with **pattern matching for `instanceof`** (Java 16+).

Example:

```java
static void printShape(Shape s) {
    if (s instanceof Circle c)
        System.out.println("Circle area: " + c.area());
}
```

üí° With **record patterns** (Java 21+), you can destructure directly:

```java
if (s instanceof Rectangle(double w, double h)) {
    System.out.println("Area: " + w * h);
}
```

instead of:
 
```java
if (s instanceof Rectangle r) {
double w = r.width();
double h = r.height();
    System.out.println("Area: " + w * h);
}
```

 **Why does this syntax improve readability?**

---

## **11. Example ‚Äì Combining Records**

```java
record Address(String city, String street) {}
record Person(String name, Address address) {}

public class Demo {
    public static void main(String[] args) {
        Address addr = new Address("Krak√≥w", "Mickiewicza 30");
        Person p = new Person("Anna", addr);

        System.out.println(p);
        // Person[name=Anna, address=Address[city=Krak√≥w, street=Mickiewicza 30]]
    }
}
```

## **12. Records vs Classes**

| Feature                 | Classic Class   | Record    | 
| ----------------------- | --------------- | --------- | 
| Boilerplate             | High            | Minimal   |
| Mutability              | Mutable         | Immutable |
| `equals()`/`hashCode()` | Must be written | Auto      |
| Immutability by default | ‚ùå               | ‚úÖ         |
| Requires Lombok lib     | ‚ùå               | ‚ùå         |

‚ö†Ô∏è Records are **language-level**, no dependency required.

---

## **13. Use Cases**

‚úÖ **Good for:**

* Data transfer objects (DTOs),
* Immutable configuration objects,
* Return types with multiple values,
* Simple domain objects in functional-style code.

‚ùå **Avoid when:**

* You need inheritance or mutable fields,
* The class holds internal logic beyond state.

---

## **14. Summary**

| Concept                 | Key idea                        |
| ----------------------- | ------------------------------- |
| **Record**              | Concise, immutable data carrier |
| **Components**          | Fields automatically defined    |
| **Compact constructor** | Validation with minimal syntax  |
| **Auto methods**        | equals, hashCode, toString      |
| **Final**               | Cannot be subclassed            |

üí° *In one sentence:*

> A record is a transparent, immutable, data-focused class.

---


## **15. References**

1. Oracle Docs ‚Äì *Records (Java 17)*
   [https://docs.oracle.com/en/java/javase/17/language/records.html](https://docs.oracle.com/en/java/javase/17/language/records.html)
2. Brian Goetz, *State of the Record: The Design of Java Records*, 2020.
3. Venkat Subramaniam, *Modern Java in Action*, Manning, 2018.
4. Nicolai Parlog, *Java Records: Concise Classes for Immutable Data*, Inside Java Blog, 2021.
5. IntelliJ IDEA Docs ‚Äì *Working with Records*.

---