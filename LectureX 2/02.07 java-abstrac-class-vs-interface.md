## Java: Abstract Classes and Interfaces

Welcome to this lecture on Abstract Classes and Interfaces in Java. These powerful constructs enable us to achieve **abstraction** in our code, a core principle of object-oriented programming.

### 1. Abstract Classes

#### 1.1 What is an Abstract Class?

An abstract class in Java is a class that cannot be instantiated. It is declared using the `abstract` keyword. Abstract classes can have:

* **Abstract methods:** Methods declared without an implementation (body). They are marked with the `abstract` keyword.
* **Concrete methods:**  Regular methods with a body.
* **Data members:** Variables to store data.

#### 1.2 Why use Abstract Classes?

* **Code Reusability:** Provide common functionality for subclasses.
* **Encapsulation:** Hide implementation details from the user.
* **Polymorphism:** Allow subclasses to provide specific implementations.

#### 1.3 Example

```java
public abstract class Animal { // Abstract class

    // Abstract method (no implementation)
    public abstract void makeSound();

    // Concrete method
    public void eat() {
        System.out.println("Animal is eating");
    }
}

public class Dog extends Animal { // Concrete subclass

    @Override
    public void makeSound() {
        System.out.println("Woof!");
    }
}
```

**Explanation:**

* `Animal` is an abstract class, cannot be instantiated.
* `makeSound` is an abstract method, must be implemented by subclasses.
* `Dog` extends `Animal` and provides a concrete implementation for `makeSound`.

#### 1.4 References

* [Oracle Documentation on Abstract Classes](https://docs.oracle.com/javase/tutorial/java/javaOO/abstractclasses.html)

---

### 2. Interfaces

#### 2.1 What is an Interface?

An interface in Java is a blueprint of a class. It is declared using the `interface` keyword. Interfaces can only have:

* **Abstract methods:** Methods without an implementation.
* **Constant variables:**  Public, static, and final by default.

#### 2.2 Why use Interfaces?

* **Multiple Inheritance:** A class can implement multiple interfaces.
* **Loose Coupling:**  Reduce dependency between classes.
* **Contract Enforcement:**  Ensure specific methods are implemented by classes.

#### 2.3 Example

```java
public interface Playable {

    // Abstract method
    void play();
}

public class MusicPlayer implements Playable {

    @Override
    public void play() {
        System.out.println("Playing music...");
    }
}
```

**Explanation:**

* `Playable` is an interface, defines a contract for classes that implement it.
* `MusicPlayer` implements `Playable` and provides a concrete implementation for `play`.

#### 2.4 References

* [Oracle Documentation on Interfaces](https://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html)

---

### 3. Abstract Class vs. Interface: Pros & Cons

| Feature        | Abstract Class                   | Interface                         |
|----------------|------------------------------------|-----------------------------------|
| Type           | Class                           | Interface                        |
| Instantiation | Cannot be instantiated         | Cannot be instantiated            |
| Methods        | Abstract and Concrete methods   | Only Abstract methods (Java 8+)  |
| Variables     | Instance variables allowed        | Only constants                   |
| Inheritance   | Single inheritance               | Multiple inheritance              |
| Relationship   | "is-a" relationship             | "can-do" or "has-a" relationship |

#### 3.1 When to use Abstract Classes?

* Share common code among closely related classes.
* Control the level of implementation provided by subclasses.
* Define methods that can be overridden by subclasses.

#### 3.2 When to use Interfaces?

* Define a contract for unrelated classes to follow.
* Achieve loose coupling and flexibility in code.
* Enable polymorphism by allowing classes to be treated based on their interface.

#### 3.3 Example

```java
// Abstract Class for Animals with basic functionality
public abstract class Animal {
    public void eat() {
        System.out.println("Animal is eating");
    }
    public abstract void move();
}

// Interface for animals that can fly
public interface Flyable {
    void fly();
}

// A bird is both an Animal and can fly
public class Bird extends Animal implements Flyable {
    @Override
    public void move() {
        System.out.println("Bird is flying");
    }

    @Override
    public void fly() {
        System.out.println("Bird is flapping its wings");
    }
}
```

**Explanation:**

* `Animal` provides common functionality but doesn't dictate how an animal moves.
* `Flyable` defines the ability to fly, applicable to any creature.
* `Bird` inherits from `Animal` and implements `Flyable`, demonstrating both relationships.

#### 3.4 References

* [Stack Overflow: Abstract Class vs Interface](https://stackoverflow.com/questions/1706272/what-is-the-difference-between-an-interface-and-abstract-class)
* [GeeksforGeeks: Abstract Class vs Interface](https://www.geeksforgeeks.org/difference-between-abstract-class-and-interface-in-java/)

This concludes the lecture on Abstract Classes and Interfaces. By understanding and appropriately using these concepts, you can write more efficient, flexible, and maintainable Java code. 
