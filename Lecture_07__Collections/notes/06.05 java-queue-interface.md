## Queue Interface in Java

This document explores the `Queue` interface in Java, its core methods, and common implementations within the Java Collections Framework.

### 1. The `Queue` Interface

The `Queue` interface in Java represents a collection designed for holding elements prior to processing. It typically follows a FIFO (First-In, First-Out) structure, although variations like priority queues exist.  The `Queue` interface extends the `Collection` interface.

**Key characteristics:**

* **Ordered:** Elements maintain their insertion order (except for priority queues).
* **FIFO (generally):** Elements are retrieved in the order they were added.
* **Dynamic Sizing:** The queue automatically resizes as needed.

**Core Methods:**

| Method          | Description                                                                        | Throws                                    |
|-----------------|------------------------------------------------------------------------------------|--------------------------------------------|
| `add(E e)`      | Inserts an element at the tail of the queue.                                       | `IllegalStateException`, `ClassCastException`, `NullPointerException`, `IllegalArgumentException` |
| `offer(E e)`    | Inserts an element at the tail. Returns `false` if it fails (e.g., capacity restrictions). | `ClassCastException`, `NullPointerException`, `IllegalArgumentException` |
| `remove()`      | Retrieves and removes the head of the queue.                                      | `NoSuchElementException`                   |
| `poll()`        | Retrieves and removes the head. Returns `null` if the queue is empty.              | None                                       |
| `element()`      | Retrieves, but does not remove, the head.                                         | `NoSuchElementException`                   |
| `peek()`        | Retrieves, but does not remove, the head. Returns `null` if the queue is empty.     | None                                       |


**Code Example:**

```java
import java.util.Queue;
import java.util.LinkedList;

public class QueueExample {
    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();
        queue.offer("Apple");
        queue.offer("Banana");
        queue.offer("Orange");

        System.out.println("Head: " + queue.peek());  // Output: Apple
        System.out.println("Removed: " + queue.poll()); // Output: Apple
        System.out.println("Size: " + queue.size());    // Output: 2
    }
}
```

**References:**

* [Java Collections Framework](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Collection.html)
* [Queue Interface](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Queue.html)


### 2. Queue Implementations in Java Collections Framework

Several classes in the Java Collections Framework implement the `Queue` interface:

**1. `LinkedList`:**

* Doubly-linked list implementation.
* Efficient for insertions and deletions at both ends.
* Not synchronized.

```java
Queue<Integer> linkedListQueue = new LinkedList<>();
```

**2. `PriorityQueue`:**

* Elements are ordered according to their natural ordering or a provided `Comparator`.
* Not thread-safe.

```java
Queue<Integer> priorityQueue = new PriorityQueue<>();
```


**3. `ArrayDeque`:**

* Resizable array implementation.
* Efficient for adding and removing elements at both ends.
* Not thread-safe.
* Can be used as a stack as well.

```java
Queue<Integer> arrayDequeQueue = new ArrayDeque<>();
```


**4. `PriorityBlockingQueue`:**

* Thread-safe version of `PriorityQueue`.
* Blocking operations available (e.g., `put`, `take`).

```java
import java.util.concurrent.PriorityBlockingQueue;
// ...
BlockingQueue<Integer> blockingPriorityQueue = new PriorityBlockingQueue<>();
```


**Choosing the right implementation:**

The best implementation depends on the specific needs of your application:

* **General purpose FIFO:** `LinkedList` or `ArrayDeque` are good choices. `ArrayDeque` is generally faster than `LinkedList`.
* **Prioritized elements:** `PriorityQueue` (non-thread-safe) or `PriorityBlockingQueue` (thread-safe).
* **Thread safety:**  Use `PriorityBlockingQueue` or synchronize access to other implementations.



**Code Example (PriorityQueue):**

```java
import java.util.PriorityQueue;
import java.util.Queue;

public class PriorityQueueExample {
    public static void main(String[] args) {
        Queue<Integer> pq = new PriorityQueue<>();
        pq.offer(3);
        pq.offer(1);
        pq.offer(4);
        pq.offer(2);

        while (!pq.isEmpty()) {
            System.out.print(pq.poll() + " "); // Output: 1 2 3 4
        }
    }
}

```


**References:**

* [LinkedList](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/LinkedList.html)
* [PriorityQueue](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/PriorityQueue.html)
* [ArrayDeque](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/ArrayDeque.html)
* [PriorityBlockingQueue](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/concurrent/PriorityBlockingQueue.html)


This material provides a solid foundation for understanding and using the `Queue` interface and its implementations in Java. Remember to consult the official documentation for the most up-to-date information and detailed explanations.
