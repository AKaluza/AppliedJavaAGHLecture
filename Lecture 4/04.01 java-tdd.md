
# **Test-Driven Development (TDD)**


## **What is Test-Driven Development (TDD)?**

> **Definition:**
> Test-Driven Development (TDD) is a **software development methodology** where tests are written **before** the code that makes them pass.

* Introduced by **Kent Beck** as part of **Extreme Programming (XP)**.
* The main idea: *â€œWrite a failing test first, then write the minimal code to make it pass.â€*

---

## **Core Principles**

| Principle               | Description                                                  |
| ----------------------- | ------------------------------------------------------------ |
| **Tests first**         | Every new functionality starts with writing a test.          |
| **Small steps**         | Add functionality in very small, incremental steps.          |
| **Refactor often**      | Improve code without changing behavior after all tests pass. |
| **Continuous feedback** | The tests provide constant feedback about correctness.       |

## **Genesis of Test-Driven Development Methodology in Java**

### **Historical Background**

* Originated from **Extreme Programming (XP)** practices in the **late 1990s**.
* Evolved from earlier concepts such as:

    * **Unit testing** (Smalltalk community, 1980s),
    * **SUnit** (created by Kent Beck for Smalltalk),
    * **xUnit architecture**, later ported to Java as **JUnit**.

### **Java Context**

* **JUnit** (introduced in 1997 by Kent Beck and Erich Gamma) became the **de facto standard** for TDD in Java.
* Javaâ€™s strong **object-oriented** paradigm and **static typing** made it ideal for applying TDD principles.

### **First Generation Tools**

* **JUnit** â€“ framework for unit testing in Java.
* **Ant & Maven** â€“ automation of test execution.
* **IDE integrations** (Eclipse, IntelliJ IDEA) promoted adoption.

ðŸ“˜ **Key Historical Reference:**

* Kent Beck, *Test-Driven Development: By Example*, Addison-Wesley, 2003.
* Erich Gamma & Kent Beck, *JUnit Cookbook*, Addison-Wesley, 2004.
* Martin Fowler, *Refactoring*, Addison-Wesley, 2018.

---



## **3. The TDD Cycle: â€œRed â€“ Green â€“ Refactorâ€**

```text
   +-------------------+
   |  Write a Test     | --> Red (fails)
   +-------------------+
             |
             v
   +-------------------+
   |  Write Code       | --> Green (passes)
   +-------------------+
             |
             v
   +-------------------+
   |  Refactor Code    | --> Clean, elegant solution
   +-------------------+
             |
             +---------------------> Repeat
```

1. **Red:** Write a failing test (expected behavior not yet implemented).
2. **Green:** Implement the simplest code that makes the test pass.
3. **Refactor:** Clean up code while keeping all tests passing.
```java
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

class CalculatorTest {

    @Test
    void testAddition() {
        Calculator calc = new Calculator();
        assertEquals(5, calc.add(2, 3));  // Fails initially
    }
}

class Calculator {
    int add(int a, int b) { return a + b; } // Minimal code to pass test
}

```


---

## **Benefits of TDD**

| Benefit               | Explanation                                            |
| --------------------- | ------------------------------------------------------ |
| **Improved Design**   | Forces modular, testable, and decoupled code.          |
| **Fewer Bugs**        | Immediate feedback ensures correctness.                |
| **Regression Safety** | Future changes are safer with a full test suite.       |
| **Documentation**     | Tests act as *executable documentation*.               |
| **Improved code quality**     | Continuous verification enforces correctness.               |
| **Cleaner design**            | Forces modular, decoupled, and reusable components.         |
| **Regression safety**         | Quick detection of new bugs introduced by changes.          |
| **Confidence in refactoring** | Enables developers to safely modify legacy code.            |
| **Encourages simplicity**     | Developers implement only the code necessary to pass tests. |

---

## **Disadvantages of Test-Driven Development in Java**

| Disadvantage                     | Description                                                         |
| -------------------------------- | ------------------------------------------------------------------- |
| **Initial overhead**             | Writing tests first slows down initial development.                 |
| **Complex setup**                | Testing interactions (e.g., databases, APIs) can be time-consuming. |
| **Not suited for all domains**   | GUI or data science code may not benefit as much.                   |
| **False sense of security**      | Passing tests â‰  absence of bugs.                                    |
| **Difficult for legacy systems** | Retrofitting TDD to untested code is challenging.                   |

---

## **TDD in Practice (Step-by-Step Example)**

### Example Problem:

Implement a simple **Calculator** that can add and subtract numbers.

---

### **Step 1: Write a Failing Test (RED)**

Weâ€™ll use **JUnit 5** for testing.

```java
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

public class CalculatorTest {

    @Test
    void testAddition() {
        Calculator calc = new Calculator();
        assertEquals(5, calc.add(2, 3)); // Expect 2 + 3 = 5
    }

    @Test
    void testSubtraction() {
        Calculator calc = new Calculator();
        assertEquals(1, calc.subtract(3, 2)); // Expect 3 - 2 = 1
    }
}
```

ðŸ’¥ The tests will **fail**, because `Calculator` doesnâ€™t exist yet.

---

### **Step 2: Write Minimal Code to Pass (GREEN)**

```java
public class Calculator {

    public int add(int a, int b) {
        return a + b;   // simplest code that works
    }

    public int subtract(int a, int b) {
        return a - b;
    }
}
```

âœ… Run tests â†’ All **pass**.

---

### **Step 3: Refactor**

No duplication yet â€” but we might:

* Introduce **logging** or **input validation**.
* Optimize test readability.

Example:

```java
@BeforeEach
void setup() {
    calc = new Calculator();
}
```

---

## **Expanding Functionality with TDD**

Letâ€™s add **division** â€” but handle divide-by-zero correctly.

### Step 1: Write a failing test

```java
@Test
void testDivision() {
    Calculator calc = new Calculator();
    assertEquals(2, calc.divide(10, 5));
}

@Test
void testDivideByZeroThrowsException() {
    Calculator calc = new Calculator();
    assertThrows(ArithmeticException.class, () -> calc.divide(10, 0));
}
```

### Step 2: Implement minimal passing code

```java
public int divide(int a, int b) {
    if (b == 0) throw new ArithmeticException("Cannot divide by zero");
    return a / b;
}
```

âœ… All tests now **green** again.

---

## **TDD with Objects and State**

Letâ€™s apply TDD to an **Account** class.

### Step 1: Failing Test

```java
@Test
void depositShouldIncreaseBalance() {
    Account acc = new Account();
    acc.deposit(100);
    assertEquals(100, acc.getBalance());
}

@Test
void withdrawShouldDecreaseBalance() {
    Account acc = new Account();
    acc.deposit(100);
    acc.withdraw(40);
    assertEquals(60, acc.getBalance());
}
```

### Step 2: Minimal Implementation

```java
public class Account {
    private int balance = 0;

    public void deposit(int amount) {
        balance += amount;
    }

    public void withdraw(int amount) {
        balance -= amount;
    }

    public int getBalance() {
        return balance;
    }
}
```

âœ… All tests pass. Later we can refactor (e.g., validation, exceptions).

---

## **8. Best Practices in TDD**

| Practice                          | Description                                         |
| --------------------------------- | --------------------------------------------------- |
| **Write the simplest test first** | Start small â€” test one behavior at a time.          |
| **One assertion per test**        | Improves readability and debugging.                 |
| **Use descriptive names**         | e.g., `shouldThrowExceptionWhenBalanceIsNegative()` |
| **Keep tests fast**               | Unit tests should run in milliseconds.              |
| **Refactor regularly**            | Clean code improves design and maintainability.     |

---

## **Common Pitfalls**

| Pitfall                            | Explanation                                               |
| ---------------------------------- | --------------------------------------------------------- |
| **Writing too many trivial tests** | Focus on meaningful behaviors, not getters/setters.       |
| **Skipping refactoring**           | Leads to â€œtest clutterâ€ and poor design.                  |
| **Testing implementation details** | Tests should validate *behavior*, not *how* itâ€™s done.    |
| **Not running tests frequently**   | Feedback loop must be short.                              |
| **Forgetting integration tests**   | TDD complements but does not replace integration testing. |

---

## **Integration with Build Tools**

TDD is usually integrated into build and CI/CD pipelines.

### Common Tools:

* **JUnit 5** â€“ Java testing framework
* **Mockito** â€“ Mocking dependencies
* **Maven / Gradle** â€“ Build automation and test execution
* **JaCoCo** â€“ Code coverage reports
* **GitHub Actions / Jenkins / GitLab CI** â€“ Continuous integration

Example command (Maven):

```bash
mvn test
```

---

## **TDD vs. Traditional Development**

| Traditional                    | TDD                             |
| ------------------------------ | ------------------------------- |
| Write code first, then test it | Write test first, then code     |
| Big design upfront             | Emergent design                 |
| Harder to refactor safely      | Continuous safety net of tests  |
| Focus on implementation        | Focus on behavior and interface |

---

## **TDD and Design Patterns**

* TDD promotes:

    * **Dependency Injection**
    * **Single Responsibility Principle (SRP)**
    * **Interface-based design**

ðŸ’¡ TDD naturally leads to **clean, decoupled, testable architecture**.

---

## **TDD in Larger Projects**

1. **Write tests for business rules** first.
2. **Mock external systems** (database, API) using Mockito or Fake Objects.
3. Maintain **fast feedback** â€” avoid slow integration dependencies.
4. Adopt **Continuous Integration (CI)** to run tests automatically on every commit.

---

## **Example: Using Mockito for TDD**

```java
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.Test;

class PaymentServiceTest {
    @Test
    void shouldCallPaymentGatewayWhenProcessingPayment() {
        PaymentGateway gateway = mock(PaymentGateway.class);
        PaymentService service = new PaymentService(gateway);

        service.process(100.0);

        verify(gateway).pay(100.0);
    }
}
```

```java
public class PaymentService {
    private PaymentGateway gateway;

    public PaymentService(PaymentGateway gateway) {
        this.gateway = gateway;
    }

    public void process(double amount) {
        gateway.pay(amount);
    }
}
```

âœ… Demonstrates **mocking dependencies** and **testing behavior**.

---

## **References**

### ðŸ“˜ **Books**

1. **Kent Beck**, *Test-Driven Development: By Example*, Addison-Wesley, 2003.
2. **Martin Fowler**, *Refactoring: Improving the Design of Existing Code*, Addison-Wesley, 2018.
3. **Robert C. Martin**, *Clean Code: A Handbook of Agile Software Craftsmanship*, Prentice Hall, 2008.
4. **Gerard Meszaros**, *xUnit Test Patterns: Refactoring Test Code*, Addison-Wesley, 2007.
5. **Lisa Crispin & Janet Gregory**, *Agile Testing*, Addison-Wesley, 2014.

---

### ðŸŒ **Online Documentation**

* [JUnit 5 User Guide (Official)](https://junit.org/junit5/docs/current/user-guide/)
* [Mockito Documentation](https://site.mockito.org/)
* [Martin Fowler â€“ TDD Overview](https://martinfowler.com/bliki/TestDrivenDevelopment.html)
* [Baeldung: TDD with JUnit and Mockito](https://www.baeldung.com/java-test-driven-development-tdd)
* [Agile Alliance â€“ Test-Driven Development](https://www.agilealliance.org/glossary/tdd/)

---

## **Summary**

> â€œTDD is not about testing. Itâ€™s about **designing software through tests**.â€
> â€” Kent Beck

**Key Takeaways:**

* Write **tests before code**.
* Keep **tests small, fast, and meaningful**.
* Refactor regularly.
* TDD ensures **quality, maintainability, and confidence** in your software.

---
