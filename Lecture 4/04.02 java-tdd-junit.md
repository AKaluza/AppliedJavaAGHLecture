# **Test-Driven Development (TDD) using JUnit in Java**

## **Introduction: TDD and JUnit**

> **Test-Driven Development (TDD)** is a software methodology that emphasizes writing **tests before code**.
> In Java, this is primarily implemented using the **JUnit testing framework**.

### **TDD Core Cycle ‚Äì ‚ÄúRed ‚Üí Green ‚Üí Refactor‚Äù**

```
1Ô∏è‚É£ RED: Write a failing test.
2Ô∏è‚É£ GREEN: Write minimal code to make it pass.
3Ô∏è‚É£ REFACTOR: Clean up code while keeping all tests passing.
```

### **JUnit‚Äôs Role**

* Provides annotations and assertions for writing unit tests.
* Supports automation, repeatability, and integration with build tools (Maven, Gradle).
* Enables TDD in a structured, standardized way.

---

## **Getting Started with JUnit**

### **Setup (JUnit 5 Example)**

**Maven dependency:**

```xml
<dependency>
  <groupId>org.junit.jupiter</groupId>
  <artifactId>junit-jupiter</artifactId>
  <version>5.10.0</version>
  <scope>test</scope>
</dependency>
```

**Gradle dependency:**

```gradle
testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
```

### **Basic Test Structure**

```java
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

class CalculatorTest {

    @Test
    void testAddition() {
        Calculator calc = new Calculator();
        assertEquals(5, calc.add(2, 3));
    }
}

class Calculator {
    int add(int a, int b) { return a + b; }
}
```

‚úÖ The test passes once the `add()` method is implemented correctly.

---

## **TDD Using JUnit in Java**

### **Step 1: Write the Test First (RED)**

```java
@Test
void testMultiply() {
    Calculator calc = new Calculator();
    assertEquals(6, calc.multiply(2, 3));  // Fails first
}
```

### **Step 2: Implement Minimal Code (GREEN)**

```java
int multiply(int a, int b) {
    return a * b;
}
```

### **Step 3: Refactor**

* Simplify logic or structure.
* Ensure naming conventions and readability.

```java
int multiply(int a, int b) {
    // No change in behavior, improved readability
    return a * b;
}
```

---

## **JUnit Annotations Overview**

| Annotation     | Purpose                                    |
| -------------- | ------------------------------------------ |
| `@Test`        | Marks a test method                        |
| `@BeforeEach`  | Runs before each test (setup)              |
| `@AfterEach`   | Runs after each test (cleanup)             |
| `@BeforeAll`   | Runs once before all tests (static setup)  |
| `@AfterAll`    | Runs once after all tests (static cleanup) |
| `@Disabled`    | Skips a test temporarily                   |
| `@DisplayName` | Adds descriptive names for readability     |

**Example:**

```java
import org.junit.jupiter.api.*;

class LifecycleTest {

    @BeforeAll static void initAll() { System.out.println("Init once"); }
    @BeforeEach void init() { System.out.println("Init each test"); }
    @Test void testOne() { System.out.println("Running test 1"); }
    @Test void testTwo() { System.out.println("Running test 2"); }
    @AfterEach void tearDown() { System.out.println("Clean up"); }
    @AfterAll static void tearDownAll() { System.out.println("All done"); }
}
```

---

## **Assertions in JUnit**

| Assertion        | Description                | Example                                                   |
| ---------------- | -------------------------- | --------------------------------------------------------- |
| `assertEquals()` | Checks equality            | `assertEquals(5, calc.add(2,3))`                          |
| `assertTrue()`   | Checks boolean condition   | `assertTrue(val > 0)`                                     |
| `assertFalse()`  | Checks false condition     | `assertFalse(list.isEmpty())`                             |
| `assertThrows()` | Checks exception thrown    | `assertThrows(IllegalArgumentException.class, () -> ...)` |
| `assertAll()`    | Groups multiple assertions | Useful for complex tests                                  |

**Example:**

```java
@Test
void testAssertions() {
    assertAll("Grouped Assertions",
        () -> assertEquals(5, 2 + 3),
        () -> assertTrue("Hello".startsWith("H")),
        () -> assertThrows(ArithmeticException.class, () -> 5/0)
    );
}
```

---

## **Types of Unit Tests in JUnit (Java Context)**

> In TDD, we categorize tests by their purpose and scope.

### **1Ô∏è‚É£ Simple Unit Tests**

* Test single methods or classes.
* Isolated from external dependencies.

```java
@Test
void shouldReturnCorrectSum() {
    assertEquals(9, new Calculator().add(4, 5));
}
```

---

### **2Ô∏è‚É£ Integration-Like Unit Tests**

* Still run in JUnit but may involve **multiple components**.

```java
@Test
void shouldCalculateOrderTotal() {
    Product p1 = new Product("Book", 10);
    Product p2 = new Product("Pen", 2);
    Order order = new Order(List.of(p1, p2));

    assertEquals(12, order.calculateTotal());
}
```

---

### **3Ô∏è‚É£ Exception and Edge Case Tests**

* Verifies behavior under invalid or edge inputs.

```java
@Test
void shouldThrowWhenDivideByZero() {
    Calculator calc = new Calculator();
    assertThrows(ArithmeticException.class, () -> calc.divide(10, 0));
}
```

---

### **4Ô∏è‚É£ Behavior/Interaction Tests (using Mockito)**

* Used when testing **collaboration** between objects.

```java
import static org.mockito.Mockito.*;

@Test
void shouldInvokePaymentProcessor() {
    PaymentProcessor processor = mock(PaymentProcessor.class);
    OrderService service = new OrderService(processor);

    service.completeOrder(100.0);

    verify(processor).pay(100.0);
}
```
More in next section.

---

## **Parameterized Unit Tests in JUnit**

> Parameterized tests allow running the **same test logic with multiple input values**, improving test coverage and reducing duplication.

### **Example 1: Using `@ValueSource`**

```java
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import static org.junit.jupiter.api.Assertions.*;

class EvenNumberTest {

    @ParameterizedTest
    @ValueSource(ints = {2, 4, 6, 8, 10})
    void testEvenNumbers(int number) {
        assertTrue(number % 2 == 0);
    }
}
```

‚úÖ Runs the same test **five times** with different integer inputs.

---

### **Example 2: Using `@CsvSource`**

```java
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

class CalculatorParameterizedTest {

    @ParameterizedTest
    @CsvSource({
        "2, 3, 5",
        "10, 5, 15",
        "-2, 2, 0"
    })
    void testAdd(int a, int b, int expected) {
        Calculator calc = new Calculator();
        assertEquals(expected, calc.add(a, b));
    }
}
```

‚úÖ Each row defines a **test case** (input ‚Üí expected output).

---

### **Example 3: Using `@MethodSource`**

```java
import org.junit.jupiter.params.provider.MethodSource;
import java.util.stream.Stream;

class AdvancedCalculatorTest {

    static Stream<Arguments> data() {
        return Stream.of(
            Arguments.of(2, 3, 5),
            Arguments.of(5, 7, 12)
        );
    }

    @ParameterizedTest
    @MethodSource("data")
    void testAddition(int a, int b, int expected) {
        Calculator calc = new Calculator();
        assertEquals(expected, calc.add(a, b));
    }
}
```

‚úÖ Allows dynamic or computed test data.

---

### **Example 4: Using `@CsvFileSource`**

```java
@ParameterizedTest
@CsvFileSource(resources = "/test-data.csv", numLinesToSkip = 1)
void testWithCsvFile(int a, int b, int expected) {
    Calculator calc = new Calculator();
    assertEquals(expected, calc.add(a, b));
}
```

**üìÑ test-data.csv:**

```
a,b,expected
1,2,3
2,3,5
10,5,15
```

---

## **Best Practices for TDD and JUnit**

| Practice                   | Explanation                             |
| -------------------------- | --------------------------------------- |
| Write small, focused tests | Each test validates a single behavior.  |
| Use descriptive test names | e.g., `shouldThrowWhenInputIsNull()`    |
| Avoid logic in tests       | Keep tests deterministic and simple.    |
| Run tests frequently       | Integrate into CI/CD pipelines.         |
| Mock dependencies          | Use Mockito for isolation.              |
| Keep tests fast            | Avoid external resources in unit tests. |

---

## **9. Common Pitfalls**

| Pitfall                           | Description                                |
| --------------------------------- | ------------------------------------------ |
| Over-testing trivial code         | Avoid redundant tests for getters/setters. |
| Ignoring refactoring              | Tests should evolve with the code.         |
| Relying on test order             | Each test must be independent.             |
| Mixing unit and integration tests | Separate them to maintain fast feedback.   |

---

## **10. References and Further Reading**

### **Books**

1. **Kent Beck**, *Test-Driven Development: By Example*, Addison-Wesley, 2003.
2. **Robert C. Martin**, *Clean Code: A Handbook of Agile Software Craftsmanship*, Prentice Hall, 2008.
3. **Gerard Meszaros**, *xUnit Test Patterns: Refactoring Test Code*, Addison-Wesley, 2007.
4. **Martin Fowler**, *Refactoring: Improving the Design of Existing Code*, Addison-Wesley, 2018.
5. **Lasse Koskela**, *Test Driven: Practical TDD and Acceptance TDD for Java Developers*, Manning, 2008.

### **Online Documentation**

* [JUnit 5 Official User Guide](https://junit.org/junit5/docs/current/user-guide/)
* [Baeldung: Guide to JUnit 5](https://www.baeldung.com/junit-5)
* [Mockito Official Site](https://site.mockito.org/)
* [Oracle Java SE Documentation ‚Äì Annotations](https://docs.oracle.com/javase/tutorial/java/annotations/)

---

## **11. Summary**

> ‚ÄúTests are not just about verifying behavior ‚Äî they shape how we design and think about software.‚Äù
> ‚Äî *Kent Beck, 2003*

### **Key Takeaways**

* TDD and JUnit go hand-in-hand for quality software.
* Unit tests should be **small, isolated, and meaningful**.
* Parameterized tests increase coverage efficiently.
* Automation (via CI/CD) ensures stability and continuous feedback.

---
