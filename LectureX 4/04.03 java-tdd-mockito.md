## **Mockito in Test-Driven Development (TDD)**

### **1. Overview**

> **Mockito** is a popular Java framework used for **mocking dependencies** in unit tests.
> It plays a crucial role in **Test-Driven Development (TDD)**, where the main idea is to test individual **units** of software **in isolation** from their environment.

In TDD, developers follow the cycle:

```
1Ô∏è‚É£ RED: Write a failing test (before implementing code)
2Ô∏è‚É£ GREEN: Write the minimal implementation to make the test pass
3Ô∏è‚É£ REFACTOR: Clean and improve the code without breaking the tests
```

Mockito provides the tools for the **"RED"** and **"GREEN"** phases by simulating interactions between objects so developers can focus on the unit being tested.

---

### **2. Why Use Mockito in TDD?**

#### ‚úÖ Isolation of Units

TDD encourages developers to design small, modular components that can be tested independently.
However, real-world applications rely on **external dependencies** such as:

* Databases
* REST APIs
* File systems
* Message queues
* Third-party services

These dependencies:

* Make tests **slow**,
* Introduce **flakiness** (unreliable results),
* Require **setup and teardown** complexity.

Mockito solves this by **mocking** ‚Äî replacing real dependencies with lightweight, controllable objects.

---

#### üîç Definition: Mock Object

> A **mock object** is a simulated object that mimics the behavior of a real object in a controlled way.
> It is used to **verify interactions** and **stub responses** without using the real dependency.

---

#### üü¢ **Goal of Mockito in TDD**

> Verify *behavior* and *interaction* between classes
> without relying on slow or unpredictable external systems.

---

### **3. Basic Mockito Example: Step-by-Step**

Let‚Äôs demonstrate Mockito usage in a TDD workflow.

---

#### **Scenario**

We are developing a small payment system.

* `PaymentService` is responsible for making payments.
* It depends on a `PaymentGateway` (e.g., a third-party service).

We want to verify that:

> When the service is asked to process a payment, it calls the gateway exactly once with the correct amount.

---

### **Step 1: Write the Test First (RED)**

> Following TDD principles, we start with a **failing test** before implementing any production code.

```java
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.Test;

class PaymentServiceTest {

    @Test
    void shouldCallPaymentGatewayOnce() {
        // Arrange ‚Äì Create mock dependency
        PaymentGateway gateway = mock(PaymentGateway.class);
        PaymentService service = new PaymentService(gateway);

        // Act ‚Äì Invoke the method under test
        service.makePayment(100.0);

        // Assert ‚Äì Verify interaction
        verify(gateway, times(1)).process(100.0);
    }
}
```

üí• This test will **fail initially** because:

* The `PaymentGateway` and `PaymentService` classes do not yet exist.
* That‚Äôs intentional ‚Äî the **RED phase**.

---

### **Step 2: Implement Minimal Code (GREEN)**

> Implement just enough code to make the test pass.

```java
interface PaymentGateway {
    void process(double amount);
}

class PaymentService {
    private final PaymentGateway gateway;

    PaymentService(PaymentGateway gateway) {
        this.gateway = gateway;
    }

    void makePayment(double amount) {
        gateway.process(amount);
    }
}
```

‚úÖ Now the test passes.

---

### **Step 3: Refactor (Clean Up)**

After passing the test, you may:

* Improve naming or readability,
* Introduce validation logic,
* Remove duplication,
* Add additional test cases.

This step ensures both **clean code** and **maintainable tests**.

---

### **4. Mockito Core Concepts**

Mockito‚Äôs power lies in its ability to:

| Concept                | Description                                             | Example                                                                  |
| ---------------------- | ------------------------------------------------------- | ------------------------------------------------------------------------ |
| **Mocking**            | Create fake dependencies.                               | `PaymentGateway mock = mock(PaymentGateway.class);`                      |
| **Stubbing**           | Define how mocks should behave when methods are called. | `when(mock.process(anyDouble())).thenReturn(true);`                      |
| **Verification**       | Check that specific methods were called.                | `verify(mock, times(1)).process(100.0);`                                 |
| **Argument Capturing** | Capture method arguments for later assertions.          | `ArgumentCaptor<Double> captor = ArgumentCaptor.forClass(Double.class);` |
| **Spying**             | Wrap a real object to monitor or partially mock it.     | `List<String> spyList = spy(new ArrayList<>());`                         |

---

### **5. Stubbing Behavior**

Mockito allows **controlling return values** of methods on mock objects.

```java
when(gateway.process(anyDouble())).thenReturn(true);
```

or simulate exceptions for testing error handling:

```java
when(gateway.process(0.0))
    .thenThrow(new IllegalArgumentException("Invalid amount"));
```

Stubbing is especially useful when:

* You need predictable results from a dependency.
* The dependency might connect to an external system.

---

### **6. Verifying Interactions**

> In behavior-driven TDD, we care not only about *what* happens (results), but also *how* components interact.

```java
verify(gateway, times(1)).process(100.0);
verifyNoMoreInteractions(gateway);
```

* `verify()` checks if a specific method was called.
* `verifyNoMoreInteractions()` ensures that no unexpected method calls occurred.

This reinforces **encapsulation** and **contract correctness** in code design.

---

### **7. Capturing Arguments**

> Sometimes you need to verify the **exact argument values** passed to a mock.

Mockito provides `ArgumentCaptor` for this purpose.

```java
import org.mockito.ArgumentCaptor;

@Test
void shouldCapturePaymentAmount() {
    PaymentGateway gateway = mock(PaymentGateway.class);
    PaymentService service = new PaymentService(gateway);

    service.makePayment(200.0);

    ArgumentCaptor<Double> captor = ArgumentCaptor.forClass(Double.class);
    verify(gateway).process(captor.capture());
    assertEquals(200.0, captor.getValue());
}
```

‚úÖ Ensures the service calls its dependency with the correct data.

---

### **8. Partial Mocks and Spies**

A **spy** is a special Mockito feature that allows partial mocking:

* You can use real methods on a real object,
* But still verify or override specific behaviors.

```java
List<String> list = new ArrayList<>();
List<String> spyList = spy(list);

spyList.add("Hello");
verify(spyList).add("Hello");
```

üü£ Useful for testing legacy code where you can‚Äôt fully isolate dependencies.

---

### **9. Complex Example: Testing Business Logic with Dependencies**

```java
class OrderRepository {
    void save(Order order) {}
}

class OrderService {
    private final OrderRepository repo;
    OrderService(OrderRepository repo) { this.repo = repo; }

    void process(Order order) {
        if (order.total() > 0)
            repo.save(order);
    }
}
```

---

**Test using Mockito:**

```java
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.Test;

class OrderServiceTest {

    @Test
    void shouldSaveOrderIfTotalIsPositive() {
        // Arrange
        OrderRepository repo = mock(OrderRepository.class);
        OrderService service = new OrderService(repo);
        Order order = new Order(100.0);

        // Act
        service.process(order);

        // Assert
        verify(repo).save(order);
    }
}
```

‚úÖ This test verifies both:

* **Business logic** (`if order.total() > 0`), and
* **Collaboration behavior** (`repo.save(order)` is called).

---

### **10. Mockito in the TDD Lifecycle**

| Phase        | Developer Action                                | Mockito‚Äôs Role                                 |
| ------------ | ----------------------------------------------- | ---------------------------------------------- |
| **RED**      | Write test for a class before implementation.   | Define mocks to simulate dependencies.         |
| **GREEN**    | Implement the simplest code to make tests pass. | Use mocks to isolate class under test.         |
| **REFACTOR** | Improve design and code structure.              | Verify all tests (including mocks) still pass. |

Mockito enables fast iteration in the **TDD feedback loop**, which leads to clean, modular architecture.

---

### **11. Benefits of Using Mockito in TDD**

| Benefit                       | Explanation                                                 |
| ----------------------------- | ----------------------------------------------------------- |
| **Isolation**                 | Tests focus solely on the class being tested.               |
| **Speed**                     | Mocks avoid expensive operations like DB or network access. |
| **Reliability**               | Predictable, reproducible test outcomes.                    |
| **Design Feedback**           | Forces better interface design and decoupled architecture.  |
| **Confidence in Refactoring** | Safe code evolution with minimal side effects.              |

---

### **12. Common Mistakes to Avoid**

| Mistake                                  | Description                                       |
| ---------------------------------------- | ------------------------------------------------- |
| **Overusing mocks**                      | Mock only dependencies, not the class under test. |
| **Testing implementation details**       | Focus on external behavior and outcomes.          |
| **Not verifying interactions**           | Tests lose their behavioral value.                |
| **Mocking data structures (e.g., List)** | Mocking core Java classes leads to fragile tests. |

---

### **13. Recommended References**

#### **Books**

1. **Kent Beck**, *Test-Driven Development: By Example*, Addison-Wesley, 2003.
2. **Lasse Koskela**, *Test Driven: Practical TDD and Acceptance TDD for Java Developers*, Manning, 2008.
3. **Gerard Meszaros**, *xUnit Test Patterns*, Addison-Wesley, 2007.
4. **Robert C. Martin**, *Clean Code: A Handbook of Agile Software Craftsmanship*, Prentice Hall, 2008.
5. **Martin Fowler**, *Mocks Aren‚Äôt Stubs* (Article, 2007).

#### **Online Resources**

* [Mockito Official Documentation](https://site.mockito.org/)
* [JUnit 5 User Guide](https://junit.org/junit5/docs/current/user-guide/)
* [Baeldung: Mockito Deep Dive](https://www.baeldung.com/mockito-series)
* [Martin Fowler‚Äôs Blog: TDD Overview](https://martinfowler.com/bliki/TestDrivenDevelopment.html)

---

### **14. Summary**

> ‚ÄúTDD with Mockito is not just about testing ‚Äî it‚Äôs about **designing flexible, decoupled, and testable software systems**.‚Äù

**Key Takeaways**

* Mockito enables **true unit isolation** in TDD.
* Focus on **behavior verification**, not implementation.
* Mock external systems for **deterministic and fast tests**.
* Combine Mockito with **JUnit 5** for robust and maintainable TDD workflows.

---