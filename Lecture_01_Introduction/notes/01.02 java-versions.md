## Java Through the Years: A Journey of Innovation

**Course Overview:** This lecture delves into the evolution of Java, exploring major versions and their defining features. We'll navigate through key advancements, illustrated by code examples and supported by external resources for further exploration.

---

### 1. Genesis: Java 1.0 (1996)

**Key Features:**

* **Object-Oriented Programming:** Embraced OOP principles like encapsulation, inheritance, and polymorphism.
* **Platform Independence:** Introduced "Write Once, Run Anywhere" (WORA) capability using the Java Virtual Machine (JVM).
* **Built-in Multithreading:** Enabled concurrent execution of program parts.
* **Security:** Provided a secure execution environment with features like the Security Manager.

**Example: "Hello, World!" in Java 1.0**

```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```



**Resources:**

* [The Java Language Environment](https://www.oracle.com/java/technologies/java-history.html)

---

### 2.  Swinging into Action: Java 1.2 (1998)

**Key Features:**

* **Swing GUI Toolkit:** Introduced a more sophisticated and flexible GUI toolkit than AWT.
* **Collections Framework:** Provided standardized data structures for efficient data management.
  * Introduced List, Set, Map, Iterator as standard data structures. 
  * Unified data handling across Java.
* **Reflection API:** Allowed inspection and modification of program structure at runtime.

**Example: Swing Button**

```java
import javax.swing.*;

public class SwingExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("Swing Example");
        JButton button = new JButton("Click Me");
        frame.getContentPane().add(button);
        frame.setSize(300, 200);
        frame.setVisible(true);
    }
}
```
```java
import java.util.*;

public class Java12Collections {
    public static void main(String[] args) {
        List fruits = new ArrayList();  // raw type
        fruits.add("Apple");
        fruits.add("Banana");

        String first = (String) fruits.get(0); // must cast
        System.out.println(first);
    }
}
```

```java
import java.lang.reflect.*;

public class ReflectionExample {
    public static void main(String[] args) {
        String text = "Hello Reflection!";
        Class<?> clazz = text.getClass(); // get runtime class info

        System.out.println("Class Name: " + clazz.getName());
        System.out.println("Methods of String class:");
        for (Method method : clazz.getDeclaredMethods()) {
            System.out.println("- " + method.getName());
        }
    }
}
```

**Resources:**

* [The Java Tutorial: Collections](https://docs.oracle.com/javase/tutorial/collections/)

---

### 3. A Generics Revolution: Java 5 (2004)

**Key Features:**

* **Generics:** Introduced type safety for collections and eliminated many casting requirements.
* **Enhanced for loop:** Provided a simpler syntax for iterating over collections and arrays.
* **Autoboxing/Unboxing:** Enabled automatic conversion between primitive types and their wrapper classes.

**Example: Generics in ArrayList**

```java
import java.util.*;

public class Java5Collections {
    public static void main(String[] args) {
        List<String> fruits = new ArrayList<>(); // generics
        fruits.add("Apple");
        fruits.add("Banana");

        // No casting needed
        for (String f : fruits) {   // enhanced for loop
            System.out.println(f);
        }

        List<Integer> numbers = new ArrayList<>();
        numbers.add(10);  // autoboxing (int -> Integer)
        int sum = numbers.get(0) + 5; // unboxing
        System.out.println("Sum = " + sum);
    }
}
```

```java
public class EnhancedForLoopExample {
    public static void main(String[] args) {
        String[] fruits = {"Apple", "Banana", "Cherry"};

        // Enhanced for loop
        for (String fruit : fruits) {
            System.out.println("I like: " + fruit);
        }
    }
}
```
```java
import java.util.*;

public class AutoboxingExample {
public static void main(String[] args) {
List<Integer> numbers = new ArrayList<>();

        // Autoboxing: int -> Integer automatically
        numbers.add(10);  
        numbers.add(20);

        // Unboxing: Integer -> int automatically
        int sum = 0;
        for (int n : numbers) {
            sum += n;  
        }

        System.out.println("Sum = " + sum);
    }
}
```
**Resources:**

* [Java Generics FAQs](https://docs.oracle.com/javase/tutorial/java/generics/index.html)

---

### 4.  Embracing Change: Java SE 7 (2011)

**Key Features:**

* **Diamond Operator (<>):** Reduced verbosity when using generics.
* **Strings in switch:** Allowed the use of strings in switch statements.
* **Try-with-resources:** Simplified exception handling by automatically closing resources.


**Example: Diamond Operator (<>)**
```java
import java.util.*;

public class Java7Collections {
public static void main(String[] args) {
// Before Java 7
List<String> oldWay = new ArrayList<String>();

        // Java 7 Diamond Operator
        List<String> newWay = new ArrayList<>();
        newWay.add("Java 7");

        System.out.println(newWay);
    }
}
```

**Example: Try-with-resources**
```java
public class TryWithResources {
    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {
            String line;
            while ((line = br.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

**Example: Strings in `switch`**

```java
public class StringSwitchExample {
    public static void main(String[] args) {
        String day = "Monday";

        switch (day) {
            case "Monday":
                System.out.println("Start of the week!");
                break;
            case "Friday":
                System.out.println("Almost weekend!");
                break;
            case "Saturday":
            case "Sunday":
                System.out.println("Weekend!");
                break;
            default:
                System.out.println("Just another day.");
        }
    }
}
```

---

### âœ… Key Points

* Cleaner than using `if-else if-else` chains with `String.equals()`.
* Behind the scenes, Java translates it into a **`String.hashCode()` check + equals comparison** for efficiency.
* Works only with **compile-time constant `String` values** (not variables as case labels).

---

ðŸ‘‰ Do you want me to also prepare a **before vs. after comparison** (Java 6 `if-else` vs Java 7 `switch` with String) to show students why this was a big improvement?


**Resources:**

* [JDK 7 Release Notes](https://www.oracle.com/java/technologies/javase/7-relnotes.html)

---

### 5.  Lambda Power: Java SE 8 (2014)

**Key Features:**

* **Lambda Expressions:** Introduced functional programming concepts, making code more concise and expressive.
* **Stream API:**  Enabled powerful data manipulation operations on collections.
* **Date and Time API:** Provided a more comprehensive and modern API for working with dates and times.

**Example: Lambda Expression**

```java
import java.util.Arrays;
import java.util.List;

public class LambdaExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

        // Using a lambda expression to print each name
        names.forEach(name -> System.out.println(name));
    }
}
```


**Example collections (Java 8 style):**
```java
import java.util.*;

public class Java8Collections {
public static void main(String[] args) {
List<String> fruits = Arrays.asList("Apple", "Banana", "Cherry", "Avocado");

        // Stream API with lambdas
        fruits.stream()
              .filter(f -> f.startsWith("A"))   // keep only A-fruits
              .map(String::toUpperCase)         // transform to uppercase
              .forEach(System.out::println);    // print
    }
}
```
**Resources:**

* [Lambda Expressions](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)

---

### 6.  Modules and More: Java SE 9 (2017)

**Key Features:**

* **Modular System (Project Jigsaw):** Introduced a modular structure to the JDK, improving performance and maintainability.
* **JShell (REPL):** Provided an interactive Read-Eval-Print Loop for experimenting with code.
* **Private methods in interfaces:** Allowed for code reuse within interfaces.

**Example: JShell**

```bash
jshell> System.out.println("Hello from JShell!");
Hello from JShell!
```

**Resources:**

* [The Java Platform Module System](https://openjdk.java.net/projects/jigsaw/)

---

### 7.  Evolving Steadily: Java SE 11 (2018) - LTS

**Key Features:**

* **Local-Variable Type Inference (var keyword):** Simplified code by allowing the compiler to infer variable types.
* **New String Methods:** Added useful methods to the String class, like `isBlank()` and `lines()`.
* **HTTP/2 Client API:** Introduced a new HTTP client with support for HTTP/2.

**Example: Local-Variable Type Inference**

```java
public class VarExample {
    public static void main(String[] args) {
        var name = "John Doe"; // Type inferred as String
        System.out.println(name);
    }
}
```

**Resources:**

* [JDK 11 Release Notes](https://www.oracle.com/java/technologies/javase/11-relnotes.html)

---

### 8.  Records and Beyond: Java SE 14 (2020) - LTS

**Key Features:**

* **Records:** Introduced a concise way to define immutable data classes.
* **Switch Expressions:** Enhanced switch statements to be more concise and expressive.
* **Pattern Matching for instanceof:** Improved pattern matching capabilities.

**Example: Records**

```java
public record Person(String firstName, String lastName, int age) {
    // Compact syntax for immutable data class
}
```

**Resources:**

* [JDK 14 Release Notes](https://www.oracle.com/java/technologies/javase/14-relnotes.html)

---

### 9. Looking Ahead:  Java SE 17 (2021) - LTS & Beyond

**Key Features:**

* **Sealed Classes:** Enhanced control over inheritance by restricting which classes can extend them.
```java
public sealed class Shape permits Circle, Square {}
final class Circle extends Shape {}
final class Square extends Shape {}

```
* **Pattern Matching for switch (Preview):** Further improved pattern matching in switch expressions.
```java
static String format(Object obj) {
    return switch (obj) {
        case Integer i -> "int " + i;
        case String s  -> "String " + s;
        default        -> "Unknown";
    };
}
``` 

**Resources:**

* [JDK 17 Release Notes](https://www.oracle.com/java/technologies/javase/17-relnotes.html)
* [OpenJDK](https://openjdk.java.net/)
  Perfect ðŸ‘Œ â€” letâ€™s extend the **timeline up to Java 21 (2023, LTS)**.
  Iâ€™ll keep the **same teaching style**: short section headers, only **major and important features**, with quick code snippets where useful.

---

### 9. Looking Ahead: Java SE 17 (2021) â€“ LTS & Beyond

**Key Features:**

* **Sealed Classes (Standard):** Restrict which classes can extend/implement a type.


* **Pattern Matching for `switch` (Preview):** Cleaner type handling in `switch`.
* **Text Blocks (Standard):** Multi-line strings with `"""`.
* **Strong Encapsulation of JDK Internals:** Improves security.
* **New macOS Rendering Pipeline (Metal API):** Replaces OpenGL.

---

### 10. Latest Milestone: Java SE 21 (2023) â€“ LTS

**Key Features:**

* **Pattern Matching for `switch` (Standard):**
  Now fully standardized (no longer preview).

  ```java
  static String test(Object obj) {
      return switch (obj) {
          case String s -> "String: " + s.toUpperCase();
          case Integer i -> "Integer doubled: " + (i * 2);
          default -> "Something else";
      };
  }
  ```

* **Record Patterns (Standard):**
  Combine records with pattern matching for powerful data deconstruction.

  ```java
  record Point(int x, int y) {}
  static void print(Point p) {
      if (p instanceof Point(int x, int y)) {
          System.out.println("x=" + x + ", y=" + y);
      }
  }
  ```

* **Virtual Threads (Standard, Project Loom):**
  Lightweight threads managed by JVM â†’ easier concurrency and massive scalability.

  ```java
  public class VirtualThreadsDemo {
      public static void main(String[] args) throws Exception {
          Thread.startVirtualThread(() -> {
              System.out.println("Hello from virtual thread!");
          }).join();
      }
  }
  ```

* **Sequenced Collections:**
  New interfaces (`SequencedCollection`, `SequencedMap`) guarantee predictable iteration order.

* **String Templates (Preview):**
  Easier and safer string interpolation.

  ```java
  String name = "Alice";
  String msg = STR."Hello, \{name}!";
  System.out.println(msg); // Hello, Alice!
  ```

* **Foreign Function & Memory API (Preview):**
  Safer replacement for JNI â†’ interact with native code and memory directly.


---

This lecture provided a glimpse into the evolution of Java.  Continuous exploration of new features and updates is essential to harnessing the full power of this versatile language.
