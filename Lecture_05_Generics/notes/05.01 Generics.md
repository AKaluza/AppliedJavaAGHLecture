# **Generics in Java**

## **1. Introduction and Motivation**

Generics were introduced in **Java 5** as part of the evolution of the Java language to improve **type safety** and **code reusability**.
Before generics, Java collections (like `ArrayList`, `HashMap`) stored elements as `Object`, which forced developers to perform **explicit type casting** and risk **runtime errors**.

Example (before Java 5):

```java
List list = new ArrayList();
list.add("Hello");
String s = (String) list.get(0); // Manual cast required
```

If the programmer mistakenly added a non-string object, the program would fail at runtime:

```java
list.add(123); // Compiles fine
String s = (String) list.get(1); // Runtime ClassCastException
```

With generics, type safety is enforced **at compile time**:

```java
List<String> list = new ArrayList<>();
list.add("Hello");
// list.add(123); // Compile-time error
String s = list.get(0); // No casting needed
```

**Key idea:** Generics let you define classes, interfaces, and methods that operate on *types as parameters*.

**Discussion:**
*Why is catching errors at compile time generally preferable to catching them at runtime?*

---

## **2. Benefits of Generics**

Generics improve both code quality and performance. They also encourage better software design through abstraction.

| Benefit                  | Description                                                  |
| ------------------------ | ------------------------------------------------------------ |
| **Type Safety**          | The compiler ensures only compatible types are used.         |
| **Elimination of Casts** | No need for explicit type casting when retrieving elements.  |
| **Reusability**          | A single class or method can work with different data types. |
| **Cleaner Code**         | APIs communicate their expected types clearly.               |
| **Performance**          | Avoids unnecessary runtime type checks and exceptions.       |

**Reflection:**
Generics are a form of *parametric polymorphism* — similar to templates in C++ or generics in C#.

---

## **3. Generic Classes**

A **generic class** introduces one or more type parameters that can be replaced with real types at compile time.

### Example 1: A Generic Box

```java
public class Box<T> {
    private T value;

    public void set(T value) { this.value = value; }
    public T get() { return value; }
}
```

Usage:

```java
Box<Integer> intBox = new Box<>();
intBox.set(42);
System.out.println(intBox.get()); // 42

Box<String> strBox = new Box<>();
strBox.set("Generics are powerful");
System.out.println(strBox.get());
```

The same class works for multiple data types.

**Lab follow-up:**
Ask students to modify `Box<T>` to include a `toString()` method and observe how the output changes for different types.

---

### Example 2: Multiple Type Parameters

```java
public class Pair<K, V> {
    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public K getKey() { return key; }
    public V getValue() { return value; }
}
```

Usage:

```java
Pair<String, Integer> age = new Pair<>("Age", 30);
System.out.println(age.getKey() + " = " + age.getValue());
```

**Discussion:**
Identify situations where multiple generic parameters make APIs more expressive (e.g., maps, tuples).

---

## **4. Generic Methods**

Generic methods define type parameters at the **method level**, rather than at the class level.

### Example 1: A Generic Print Method

```java
public class Utils {
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.print(element + " ");
        }
        System.out.println();
    }
}
```

Usage:

```java
Integer[] nums = {1, 2, 3};
String[] words = {"Java", "Python", "C++"};

Utils.printArray(nums);
Utils.printArray(words);
```

**Concept:**
The `<T>` before the return type declares a **type parameter**, which allows the method to infer the type from the argument.

**Pitfall:**
The `<T>` must appear **before** the return type — otherwise, the compiler won’t recognize it as a generic method.

---

## **5. Bounded Type Parameters**

In some cases, we want to restrict the kinds of types that can be used as arguments.

### Example 1: Upper Bound (`extends`)

```java
public class Calculator<T extends Number> {
    public double square(T number) {
        return number.doubleValue() * number.doubleValue();
    }
}
```

Usage:

```java
Calculator<Integer> intCalc = new Calculator<>();
System.out.println(intCalc.square(5)); // 25.0

Calculator<String> strCalc = new Calculator<>(); // Compile error
```

Only types that **extend `Number`** (e.g., `Integer`, `Double`) are valid.

---

### Example 2: Lower Bound (`super`)

Used mainly in **wildcards**, lower bounds allow passing supertypes of a specific type.
We’ll revisit this in section 7 (wildcards).

**Lab follow-up:**
Have students implement a generic `max()` method for any `Comparable<T>` type.

---

## **6. Wildcards in Generics**

Wildcards (`?`) provide flexibility when working with **unknown or variable types**.
They are particularly useful when designing methods that accept a variety of parameterized types.

---

### **6.1 Types of Wildcards**

| Wildcard        | Description                            | Example                  |
| --------------- | -------------------------------------- | ------------------------ |
| `<?>`           | Unbounded wildcard – any type          | `List<?> list`           |
| `<? extends T>` | Upper bounded – type is T or subtype   | `List<? extends Number>` |
| `<? super T>`   | Lower bounded – type is T or supertype | `List<? super Integer>`  |

---

### Example 1: Unbounded Wildcard

```java
public static void printList(List<?> list) {
    for (Object obj : list)
        System.out.println(obj);
}
```

Accepts lists of any type but cannot safely add elements.

---

### Example 2: Upper-Bounded Wildcard

```java
public static double sumNumbers(List<? extends Number> numbers) {
    double sum = 0;
    for (Number n : numbers)
        sum += n.doubleValue();
    return sum;
}
```

Can read safely, but cannot add elements to `numbers`.

---

### Example 3: Lower-Bounded Wildcard

```java
public static void addIntegers(List<? super Integer> list) {
    list.add(10);
    list.add(20);
}
```

Safe for adding integers, but not for reading them back as integers.

---

### **6.2 The PECS Principle**

> **PECS** stands for **Producer Extends, Consumer Super.**

| Use Case            | Guideline         | Example                  |
| ------------------- | ----------------- | ------------------------ |
| Producing (reading) | Use `? extends T` | `List<? extends Number>` |
| Consuming (writing) | Use `? super T`   | `List<? super Integer>`  |

**Reflection:**
This principle helps decide which wildcard to use based on method intent.

---

## **7. Type Erasure**

Generics in Java are implemented via **type erasure** to maintain backward compatibility with older (pre-Java 5) code.

At compile-time, all generic type information is **removed**.
This means that the compiled bytecode does not retain the actual parameterized type.

Example:

```java
Box<Integer> intBox = new Box<>();
Box<String> strBox = new Box<>();

System.out.println(intBox.getClass() == strBox.getClass()); // true
```

The JVM treats both as `Box<Object>` internally.

**Implication:**
You cannot use generics with primitive types, create arrays of generics, or use `instanceof` with parameterized types.

---

## **8. Common Pitfalls**

| Pitfall                | Description                                                     | Example               |
| ---------------------- | --------------------------------------------------------------- | --------------------- |
| Generic arrays         | Illegal to create `new T[10]`                                   | Use `List<T>` instead |
| Raw types              | `List list = new ArrayList();` — loses type safety              |                       |
| Type erasure confusion | `Box<Integer>` and `Box<String>` appear identical at runtime    |                       |
| Overusing wildcards    | Makes code hard to read and maintain                            |                       |
| Static context         | Cannot use type parameters in static methods of generic classes |                       |

**Discussion:**
Think about why type erasure was necessary for backward compatibility and what drawbacks it causes today.

---

## **9. Summary and Key Takeaways**

* Generics bring **compile-time type safety** to Java programs.
* Generic **classes** and **methods** allow code reuse across types.
* **Bounds** (`extends` and `super`) restrict allowable type parameters.
* **Wildcards** provide flexibility for handling multiple parameterized types.
* **Type erasure** enables backward compatibility but imposes some limitations.

**Final Reflection:**
Generics are more than syntax — they shape how you think about *type relationships* and *abstraction* in Java.

**Lab Follow-up Ideas:**

1. Implement a generic `Pair<K,V>` with equals and hashCode.
2. Create a `sumList()` method that works with any numeric list.
3. Test wildcard behavior with `List<? super Number>` and `List<? extends Number>`.

---

## **References**

1. **Herbert Schildt**, *Java: The Complete Reference*, 12th Edition, McGraw-Hill, 2022.
2. **Joshua Bloch**, *Effective Java*, 3rd Edition, Addison-Wesley, 2018.
3. **Cay S. Horstmann**, *Core Java Volume I – Fundamentals*, 12th Edition, Pearson, 2021.
4. **Maurice Naftalin & Philip Wadler**, *Java Generics and Collections*, O’Reilly Media, 2006.
5. **Oracle Java SE Documentation – Generics:** [https://docs.oracle.com/javase/tutorial/java/generics/](https://docs.oracle.com/javase/tutorial/java/generics/)
6. **Baeldung:** [Guide to Java Generics](https://www.baeldung.com/java-generics)
7. **Martin Fowler:** [https://martinfowler.com/bliki/TestDrivenDevelopment.html](https://martinfowler.com/bliki/TestDrivenDevelopment.html)

---
